from codegen.codegen_visitor import CodegenVisitor
from models.dnn_model.dnn import DNN
from codegen.tensorrt.cpp.cpp_layer_visitor import visit_layer
from codegen.tensorrt.cpp.cpp_external_ios_visitor import visit_dnn_io, simulate_dnn_io
from models.dnn_model.param_shapes_generator import generate_param_shapes_dict
from util import elements_prod
import traceback


def visit_dnn(dnn: DNN, directory, gpu_profile):
    filepath = directory + "/" + dnn.name + ".cpp"
    with open(filepath, "w") as print_file:
        visitor = DNNTRTCPPVisitor(dnn, print_file, gpu_profile)
        visitor.visit()


class DNNTRTCPPVisitor(CodegenVisitor):
    def __init__(self, dnn: DNN, print_file, profile: bool):
        """
        Create new CPP-code visitor of a DNN/DNN partition
        :param dnn: DNN to visit
        :param print_file: open file to print CPP code of the DNN
        :param profile: include profiling code
        """
        super().__init__(print_file, prefix="")
        self.dnn = dnn
        self.profile = profile
        self.input_layer = self.dnn.get_input_layer()
        self.output_layer = self.dnn.get_output_layer()
        self.class_name = dnn.name

    def visit(self):
        stage = "beginning"
        try:
            # self.write_line("Now the file has more content!")
            self._write_common_cpp_beginning()
            stage = "partition "
            self._write_partition()
            stage = "init params "
            self._init_params()
            stage = "dummy weights "
            self._generate_dummy_weights()
            stage = "constructor and destructor "
            self._write_constructor()
            self._write_destructor()
            # print("partition: " + self.class_name + " generated ")
        except Exception:
            print(".cpp file creation error for DNN/partition " + self.class_name + " stage = " + stage)
            traceback.print_exc()

    def _write_common_cpp_beginning(self):
        """
        * Write common beginning for all generated nodes, contains:
        * - definition of header
        * - definition of standard libraries
        * - definition of namespace
        *
        : param className name of the .cpp class
        """
        self.write_line("// File automatically generated by ESPAM")
        self.write_line("")
        # tensorrt classes
        self.write_line("#include \"NvInfer.h\"")
        self.write_line("#include \"common.h\"")
        self.write_line("#include \"cuda_runtime_api.h\"")

        self.write_line("#include <map>")
        self.write_line("#include <vector>")
        self.write_line("#include <thread>")

        self.write_line("#include \"" + self.class_name + ".h\"")
        # base class name
        self.write_line("#include \"gpu_partition.h\"")

        self.write_line("")
        self.write_line("using namespace std;")
        self.write_line("using namespace nvinfer1;")
        self.write_line("")

    def _write_partition(self):
        """
        Neural Newtwork (NN)/ NN partition ENGINE with C++ API
        """
        self.write_line("//NETWORK ENGINE WITH API")
        self.write_line(
            "ICudaEngine* " + self.class_name + "::createEngine(std::map<std::string, Weights>& weightMap," +
            " unsigned int maxBatchSize, IBuilder* builder, nvinfer1::DataType dt) {")
        self.prefix_inc()
        self.write_line("INetworkDefinition* network = builder->createNetwork();")
        self.write_line("")

        # create topology
        self._define_inputs()

        for layer in self.dnn.get_layers():
            visit_layer(self.dnn, layer, self.print_file, self.prefix)
            self.write_line("")

        self._define_outputs()
        self.write_line("// Build engine")

        # Build engine
        self.write_line("builder->setMaxBatchSize(maxBatchSize);")
        self.write_line("builder->setMaxWorkspaceSize(this->WORKSPACE_SIZE << 20);")
        self.write_line("ICudaEngine* engine = builder->buildCudaEngine(*network);")

        self.write_line("// Don't need the network any more")
        self.write_line("network->destroy();")
        # std::cout << "network 1 destroyed!" << std::endl

        self.write_line("return engine;")

        self.write_line("")

        self.prefix_dec()
        self.write_line("}")
        self.write_line("")

    def _define_inputs(self):
        """
        Define DNN/DNN partition inputs (external data sources)
        :return:
        """
        external_inputs = self.dnn.get_inputs()
        if not external_inputs:
            simulate_dnn_io(self.input_layer, self.print_file, self.prefix, is_input=True)
        else:
            for io_id in range(len(external_inputs)):
                visit_dnn_io(external_inputs[io_id], io_id, self.print_file, self.prefix, is_input=True)

    def _define_outputs(self):
        """
        Define DNN/DNN partition outputs (external data consumers)
        :return:
        """
        external_outputs = self.dnn.get_outputs()
        if not external_outputs:
            simulate_dnn_io(self.output_layer, self.print_file, self.prefix, is_input=False)
        else:
            for io_id in range(len(external_outputs)):
                visit_dnn_io(external_outputs[io_id], io_id, self.print_file, self.prefix, is_input=False)

    def _init_params(self):
        """
         Write init parameters function
        """
        self.write_line("//init params function")

        self.write_line("void " + self.class_name + "::init_params(){ ")
        self.prefix_inc()
        self.write_line("this->batchSize = 1;")
        self.write_line("this->WORKSPACE_SIZE = 4;")

        if self.profile:
            self.write_line("this->detailed_profile = true;")

        self.write_line("this->IObindings = " + str(self._get_io_bindings_num()) + ";")

        self._define_input_blobs()
        self._define_output_blobs()
        self.prefix_dec()
        self.write_line("}")
        self.write_line("")

    def _get_io_bindings_num(self):
        """
         Get number of external I/Os, providing/consuming data for DNN/partition
         The external I/Os should be explicitly speficied for every visited DNN/DNN partition
         If these are unspecified, we assume that:
                1) A DNN/DNN partition has only one input_examples layer and one output layer
                2) only the input_examples and the output layers of the DNN/partition communicate
                with external data sources.
        :return: umber of external I/Os, providing/consuming data for DNN/partition
        """
        external_inputs = self.dnn.get_inputs()
        external_outputs = self.dnn.get_outputs()
        in_bindings = 1 if not external_inputs else len(external_inputs)
        out_bindings = 1 if not external_outputs else len(external_outputs)

        io_bindings = in_bindings + out_bindings
        return io_bindings
    
    def _define_input_blobs(self):
        """
            Define input_examples blobs (external data sources) of the DNN/DNN partition
        """
        external_inputs = self.dnn.get_inputs()

        # no external inputs specified
        if not external_inputs:
            input_blob_name = self.input_layer.name if self.input_layer.op == "data" else self.input_layer.name + "_input"
            self.write_line("this->INPUT_BLOB_NAME = \"" + input_blob_name + "\";")
            self.write_line("this->INPUT_C = " + str(self.input_layer.ifm) + ";")
            self.write_line("this->INPUT_H = " + str(self.input_layer.ih) + ";")
            self.write_line("this->INPUT_W = " + str(self.input_layer.iw) + ";")
            
        # from explicitly specified external inputs:
        else:
            first_input = external_inputs[0]
            first_input_blob_name = first_input.data_layer.name
            self.write_line("this->INPUT_BLOB_NAME = \"" + first_input_blob_name + "\";")
            self.write_line("this->INPUT_C = " + str(self.input_layer.ifm) + ";")
            self.write_line("this->INPUT_H = " + str(self.input_layer.ih) + ";")
            self.write_line("this->INPUT_W = " + str(self.input_layer.iw) + ";")
            self.write_line("")
            # typically DNN/DNN partition has only one input_examples blob as defined above
            # If DNN/DNN partition occurs to have more than one input_examples,
            # all inputs, starting from the second one are defined separately
            # as additional input_examples blobs
            for dnn_input in external_inputs[1:]:
                input_blob_name = dnn_input.data_layer.name
                self.write_line("this->ADDITIONAL_INPUT_BLOB_NAMES.push_back(\"" + input_blob_name + "\")")

                # the parameters of additional input_examples blobs also specified separately
                external_input_layer = dnn_input.data_layer
                self.write_line(" this->ADDITIONAL_INPUT_H.push_back(" + str(external_input_layer.oh) + ");")
                self.write_line(" this->ADDITIONAL_INPUT_W.push_back(" + str(external_input_layer.ow) + ");")
                self.write_line(" this->ADDITIONAL_INPUT_C.push_back(" + str(external_input_layer.ofm) + ");")

    def _define_output_blobs(self):
        """
            Define output blobs (external data consumers) of the DNN/DNN partition
        """
        external_outputs = self.dnn.get_outputs()

        # no external outputs specified
        if not external_outputs:
            output_blob_name = self.output_layer.name if self.output_layer.op == "data" else self.output_layer.name + "_output"
            self.write_line("this->OUTPUT_BLOB_NAME = \"" + output_blob_name + "\";")
            self.write_line("this->OUTPUT_C = " + str(self.output_layer.ofm) + ";")
            self.write_line("this->OUTPUT_H = " + str(self.output_layer.oh) + ";")
            self.write_line("this->OUTPUT_W = " + str(self.output_layer.ow) + ";")
            self.write_line("this->OUTPUT_SIZE = OUTPUT_C * OUTPUT_H * OUTPUT_W;")

        # from explicitly specified external inputs:
        else:
            first_output = external_outputs[0]
            first_output_blob_name = first_output.data_layer.name
            self.write_line("this->OUTPUT_BLOB_NAME = \"" + first_output_blob_name + "\";")
            self.write_line("this->OUTPUT_C = " + str(self.output_layer.ofm) + ";")
            self.write_line("this->OUTPUT_H = " + str(self.output_layer.oh) + ";")
            self.write_line("this->OUTPUT_W = " + str(self.output_layer.ow) + ";")
            self.write_line("this->OUTPUT_SIZE = OUTPUT_C * OUTPUT_H * OUTPUT_W;")
            self.write_line("")
        # NOTE: currently one one output blob per DNN/DNN partition is possible!
        # TODO: extend for more outputs

    def _generate_dummy_weights(self):
        self.write_line("//generate dummy weights")
        self.write_line("void " + self.class_name + "::generate_dummy_weights() {")

        self.prefix_inc()
        self.write_line("//Weight blob names ")
        self.write_line("std::vector<std::string> names;")
        self.write_line("//Weight blob sizes ")
        self.write_line("std::vector<uint32_t> sizes;")

        # generate dummy weights for every layer
        for layer in self.dnn.get_layers():
            # we only simulate weights and biases now
            # other parameters (e.g. BN parameters are not simulated (set to 0))
            simulate_shape_for = ["weights", "bias"]
            param_shapes_dict = generate_param_shapes_dict(layer)
            for param_shapes_item in param_shapes_dict.items():
                param_name, param_shape = param_shapes_item
                self.write_line("names.push_back(\"" + layer.name + "_" + param_name + "\");")
                # we only simulate weights and biases now
                # other parameters (e.g. BN parameters are not simulated (set to 0))
                elements_in_param_tensor = elements_prod(param_shape) if param_name in simulate_shape_for else 0
                self.write_line("sizes.push_back(" + str(elements_in_param_tensor) + ");")

        self.write_line("")
        self.write_line("generate_dummy(names, sizes);")

        self.prefix_dec()
        self.write_line("}")
        self.write_line("")
        
    def _write_constructor(self):
        """ Write class constructor"""
        self.write_line("//constructor")
        self.write_line(self.class_name + "::" + self.class_name + "(){")
        self.prefix_inc()
        self.write_line("init_params();")
        self.write_line("generate_dummy_weights();")
        self.write_line("init_partition();")
        self.prefix_dec()
        self.write_line("}")
        self.write_line("")

    def _write_destructor(self):
        """Write class destructor"""
        self.write_line("//destructor")
        self.write_line(self.class_name + "::~" + self.class_name + "() {}")
        self.write_line("")

