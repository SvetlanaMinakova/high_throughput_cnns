from models.dnn_model.dnn import DNN
from codegen.codegen_visitor import CodegenVisitor
from codegen.arm_cl.dnn_to_streams import DNNSubStreamsGenerator


def visit_dnn(dnn: DNN, directory:str, profile: bool, sub_streams_generator: DNNSubStreamsGenerator):
    """Call. header (.h) visitor"""
    filepath = directory + "/" + dnn.name + ".h"
    with open(filepath, "w") as print_file:
        visitor = DNNARMCLHVisitor(dnn, print_file, profile, sub_streams_generator)
        visitor.visit()


class DNNARMCLHVisitor(CodegenVisitor):
    def __init__(self, dnn: DNN, print_file, profile: bool, sub_streams_generator: DNNSubStreamsGenerator):
        """
        Create new CPP-code visitor of a DNN/DNN partition
        :param dnn: DNN to visit
        :param print_file: open file to print CPP code of the DNN
        :param gpu_profile: include profiling code
        """
        super().__init__(print_file, prefix="")
        self.dnn = dnn
        self.profile = profile
        self.input_layer = self.dnn.get_input_layer()
        self.output_layer = self.dnn.get_output_layer()
        self.class_name = dnn.name
        self.base_class_name = "Example"
        self.streams_generator = sub_streams_generator

    def visit(self):
        self._write_common_beginning()
        self._write_common_end()

    def _write_common_beginning(self):
        self.write_line("// File automatically generated by ESPAM")
        self.write_line("")
        self.write_line("#ifndef " + self.class_name + "_H")
        self.write_line("#define " + self.class_name + "_H")
        self.write_line("")
        self._include_libs()
        self.write_line("")
        self._include_namespaces()
        self.write_line("")
        self.write_line("class " + self.class_name + " : public " + self.base_class_name + " {")
        self.write_line("public:")
        self.prefix_inc()

        self.write_line(self.class_name + "(): cmd_parser(), common_opts(cmd_parser), common_params(), graph(0, \"" +
                        self.class_name + "\") { };")
        self.write_line("")

        self.write_line("//DNN-dependent functions")
        self.write_line("bool do_setup(int argc, char **argv) override;// DNN")
        self.write_line("void do_run() override; //run DNN")

        self.write_line("")
        self.write_line("//DNN-dependent parameters")
        self._init_params()
        self.write_line("")

        self.write_line("private:")
        self.prefix_inc()
        self.write_line("CommandLineParser  cmd_parser;")
        self.write_line("CommonGraphOptions common_opts;")
        self.write_line("CommonGraphParams  common_params;")
        self.write_line("Stream             graph;")

        self.write_line("")
        self.write_line("//DNN-dependent functions")

        self._define_parallel_branches_func_calls()

        self.prefix_dec()

        self.write_line("")
        self.prefix_dec()

    def _define_parallel_branches_func_calls(self):
        if not self.streams_generator.is_multi_branch_dnn():
            return

        # self.write_line("SimpleOption<unsigned int> *model_input_width{ nullptr };")
        # self.write_line("SimpleOption<unsigned int> *model_input_height{ nullptr };")
        # self.write_line("")
        self.write_line("// add parallel streams")
        sub_stream_groups = self.streams_generator.get_sub_stream_groups()
        for group_id in range(len(sub_stream_groups)):
            group = sub_stream_groups[group_id]
            sub_streams = group.sub_streams
            if (len(sub_streams)) > 1:
                self._define_function_call_for_substream_group(group_id)

        self.prefix_dec()

    def _define_function_call_for_substream_group(self, group_id):
        self.write_line("void add_sub_streams_group_" + str(group_id) +
                        "(const std::string &data_path, DataLayout weights_layout);")

    def _include_libs(self):
        # ARM CL classes
        arm_cl_headers = ["arm_compute/graph", "support/ToolchainSupport",
                          "utils/CommonGraphOptions", "utils/GraphUtils", "utils/Utils"]
        std_lib_headers = ["chrono", "thread"]
        for header in arm_cl_headers:
            self._include_local_cpp_header(header)
        for header in std_lib_headers:
            self._include_std_cpp_header(header)

    def _include_namespaces(self):
        namespaces = ["arm_compute::utils", "arm_compute::graph::frontend", "arm_compute::graph_utils"]
        for namespace in namespaces:
            self._include_namespace(namespace)

    def _init_params(self):
        input_layer = self.dnn.get_input_layer()
        output_layer = self.dnn.get_output_layer()
        self.prefix_inc()
        self.write_line("int batchSize = 1;")
        self.write_line("const char* INPUT_BLOB_NAME = \"" + input_layer.name + "\";")
        self.write_line("const char* OUTPUT_BLOB_NAME = \"" + output_layer.name + "\";")

        self.write_line("int INPUT_C = " + str(input_layer.ifm) + ";")
        self.write_line("int INPUT_H = " + str(input_layer.ih) + ";")
        self.write_line("int INPUT_W = " + str(input_layer.iw) + ";")
        self.write_line("")

        self.write_line("int OUTPUT_C = " + str(output_layer.ofm) + ";")
        self.write_line("int OUTPUT_H = " + str(output_layer.oh) + ";")
        self.write_line("int OUTPUT_W = " + str(output_layer.ow) + ";")
        self.write_line("int OUTPUT_SIZE = OUTPUT_C * OUTPUT_H * OUTPUT_W;")
        self.write_line("")

        self.write_line("float execTimeMS = 0;")
        self.prefix_dec()

    def _write_common_end(self):
        self.write_line("};")
        self.write_line("#endif // " + self.class_name + "_H")
        
