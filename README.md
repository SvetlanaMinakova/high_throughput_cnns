## Code for scientific paper Combining Task- and Data-level Parallelism for High-Throughput CNN Inference on Embedded CPUs-GPUs MPSoCs"
### authors: Svetlana Minakova, Erqian Tang, and Todor Stefanov
paper published In Proc. "20th International Conference on Embedded Computer Systems: Architectures, Modeling and Simulation (SAMOS'20)", pp. 18-35, Pythagoreio, Samos Island, Greece, July 05-09, 2020."

The code is aimed at increasing throughput of a Convolutional Neural Network (CNN), executed on an edge (mobile or embedded) platform.


## requirements
* python 3.6+
* onnx 1.8
* [optionally] keras for keras models

## inputs and outputs
*Examples of the tool inputs and outputs are located in ./input_examples folder*
The tool accepts as input:
* a DNN in ONNX (see https://onnx.ai/) format. *For an example see ./input_examples/dnn/mnist.onnx*
* a target platform architecture in json format. *For an example see ./input_examples/architecture/jetson.json*
* step-specific intermediate files in .json format, generated by the tool. *For examples see ./input_examples/high_throughput folder*


## Toolflow

Tool consists of several steps, executed one after another. 
The steps are represented as API scripts, located in the root directory of the project.
Shortly, the steps are:
1) Generation of an SDF (task graph) from an input CNN (dnn_to_sdf_task_graph.py)
2) Generation of a per-layer execution time (latency) evaluation template (sdf_latency_eval_template.py)
3) Filling the generated per-layer execution time (latency) template with real latency estimations (this step is performed manually!)
4) Generation of efficient mapping of the input CNN onto target edge platform architecture (map_and_partition.py)
5) Generation of final (CSDF) application model (generate_final_app_model.py)
6) Generation of executable code from the input DNN and the final application model (see generate_code*.py)

Below, more detailed explanation for every step (script) is given
